<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Keyboard Master - A browser-based keyboard clicking game.">
    <title>Keyboard Master (Bundled)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        /* CSS CONTENT */
        :root {
            --bg-color: #0f172a;
            --panel-bg: rgba(30, 41, 59, 0.7);
            --accent-color: #38bdf8;
            --secondary-color: #ec4899;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --border-color: rgba(148, 163, 184, 0.2);
            --font-family: 'Outfit', sans-serif;
            --animation-speed: 0.1s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-image:
                radial-gradient(at 0% 0%, rgba(56, 189, 248, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 0%, rgba(236, 72, 153, 0.15) 0px, transparent 50%);
        }

        #game-container {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100%;
            padding: 2rem;
            gap: 1.5rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            letter-spacing: -0.05rem;
            text-transform: uppercase;
        }

        .highlight {
            color: var(--accent-color);
        }

        #status-bar {
            display: flex;
            gap: 2rem;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .stat-box .label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05rem;
        }

        .stat-box .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
        }

        main {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            gap: 2rem;
            height: 100%;
            overflow: hidden;
        }

        /* Panels */
        .panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .panel h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            color: var(--secondary-color);
        }

        .scroll-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            padding-right: 0.5rem;
        }

        .scroll-list::-webkit-scrollbar {
            width: 6px;
        }

        .scroll-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        /* Upgrade Item */
        .upgrade-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .upgrade-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .upgrade-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        .upgrade-item h3 {
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .upgrade-cost {
            color: var(--accent-color);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .upgrade-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* Achievement Item */
        .achievement-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: rgba(255, 255, 255, 0.03);
            padding: 0.5rem;
            border-radius: 0.5rem;
            opacity: 0.4;
            transition: opacity 0.3s;
        }

        .achievement-item.unlocked {
            opacity: 1;
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid var(--accent-color);
        }

        .achieve-icon {
            font-size: 1.5rem;
        }

        .achieve-info h4 {
            font-size: 0.9rem;
        }

        .achieve-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Center Panel (Game Area) */
        #center-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #key-display {
            position: relative;
            width: 100%;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .massive-key {
            font-size: 4rem;
            font-weight: 900;
            color: var(--bg-color);
            background: var(--text-main);
            width: 300px;
            height: 120px;
            border-radius: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 10px 0 #cbd5e1, 0 20px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.05s ease, box-shadow 0.05s ease;
            user-select: none;
            cursor: pointer;
            text-shadow: none;
        }

        .massive-key:active,
        .massive-key.pressed {
            transform: translateY(10px);
            box-shadow: 0 0 0 #cbd5e1, 0 0 0 rgba(0, 0, 0, 0);
        }

        .instruction {
            margin-top: 2rem;
            color: var(--text-muted);
            font-size: 1.2rem;
            animation: pulse 2s infinite;
        }

        /* Floating Numbers */
        .floating-text {
            position: absolute;
            color: var(--accent-color);
            font-weight: 800;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 1s forwards ease-out;
            text-shadow: 0 0 10px var(--accent-color);
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }

        /* Minigame Overlay */
        #minigame-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #minigame-overlay.hidden {
            display: none;
        }

        .minigame-content {
            background: var(--panel-bg);
            padding: 3rem;
            border-radius: 1rem;
            text-align: center;
            border: 1px solid var(--accent-color);
            box-shadow: 0 0 50px rgba(56, 189, 248, 0.3);
            max-width: 600px;
            width: 90%;
        }

        #start-minigame-btn {
            background: var(--accent-color);
            border: none;
            padding: 1rem 3rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--bg-color);
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 2rem;
            transition: transform 0.2s;
        }

        #start-minigame-btn:hover {
            transform: scale(1.05);
        }

        /* Minigame Play Area */
        .rhythm-target {
            width: 60px;
            height: 60px;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            margin: 10px;
        }

        .rhythm-target.hit {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        .rhythm-target.miss {
            background: red;
            border-color: red;
        }

        .challenge-btn {
            margin-top: 2rem;
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(236, 72, 153, 0.4);
        }

        .challenge-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(236, 72, 153, 0.6);
        }

        .challenge-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--text-muted);
            box-shadow: none;
        }

        .minigame-selector-panel {
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .minigame-selector-panel h3 {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
            color: var(--text-muted);
        }

        .challenge-btn {
            font-size: 0.9rem;
            padding: 0.75rem 1rem;
            margin-top: 0;
        }

        #corner-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-color);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            font-family: var(--font-family);
            z-index: 50;
            text-align: right;
            min-width: 150px;
        }

        #corner-counter .label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <header>
            <h1>KEYBOARD <span class="highlight">MASTER</span></h1>
            <div id="status-bar">
                <div class="stat-box">
                    <span class="label">Total Presses</span>
                    <span id="total-presses" class="value">0</span>
                </div>
                <div class="stat-box">
                    <span class="label">Presses/Sec</span>
                    <span id="pps" class="value">0.0</span>
                </div>
                <div class="stat-box">
                    <span class="label">Keys Unlocked</span>
                    <span id="keys-unlocked" class="value">1</span>
                </div>
            </div>
        </header>

        <main>
            <div id="left-panel">
                <div class="panel upgrades-panel">
                    <h2>Upgrades</h2>
                    <div id="upgrades-list" class="scroll-list"></div>
                </div>
            </div>

            <div id="center-panel">
                <div id="key-display">
                    <div class="key massive-key" id="main-key">SPACE</div>
                    <div id="floating-text-container"></div>
                </div>
                <div id="active-minigame" class="hidden"></div>

                <p class="instruction">Press <span id="target-key-name">SPACE</span> to generate presses!</p>
                <div id="active-keys-list"
                    style="margin-top:0.5rem; color:var(--text-muted); font-size:0.9rem; text-align:center; max-width:400px; word-wrap:break-word;">
                    Active Keys: Space, W, A, S, D
                </div>

                <div class="minigame-selector-panel">
                    <h3>Minigames</h3>
                    <div style="display:flex; gap:10px; margin-top:10px;">
                        <button id="btn-speed" class="challenge-btn">Speed Challenge</button>
                        <button id="btn-reaction" class="challenge-btn">Reaction Test</button>
                    </div>
                    <div id="minigame-status" style="margin-top:5px; color:var(--secondary-color); font-size:0.9rem;">
                        Ready</div>
                </div>
            </div>

            <div id="right-panel">
                <div class="panel achievements-panel">
                    <h2>Achievements</h2>
                    <div id="achievements-list" class="scroll-list"></div>
                </div>
                <div class="panel leaderboard-panel">
                    <h2>Leaderboard</h2>
                    <div id="leaderboard-list" class="scroll-list"></div>
                </div>
            </div>
        </main>

        <div id="minigame-overlay" class="hidden">
            <div class="minigame-content">
                <h2 id="minigame-title">Speed Challenge</h2>
                <p id="minigame-desc">Press as fast as you can!</p>
                <div id="minigame-timer">Time: 10s</div>
                <div id="minigame-score">Score: 0</div>
                <button id="start-minigame-btn">Start</button>
                <div id="minigame-play-area"></div>
            </div>
        </div>

        <div id="corner-counter" class="corner-stat">
            <div class="label">Next Key Unlock</div>
            <div id="corner-progress" style="font-weight:bold; color:var(--accent-color)">0 / 1000</div>
            <div id="corner-remaining" style="font-size:0.8em; color:var(--text-muted)">1000 to go</div>
        </div>

    </div>

    <script>
        // JS CONTENT
        const UPGRADES = [
            {
                id: 'mechanical_switch',
                name: 'Mechanical Switches',
                baseCost: 15,
                multiplier: 0,
                bonus: 1,
                desc: '+1 Press per key',
                type: 'click',
                costFactor: 1.5
            },
            {
                id: 'auto_clicker',
                name: 'Auto-Key Presser',
                baseCost: 100,
                multiplier: 0,
                bonus: 1,
                desc: '+1 Press per second',
                type: 'auto',
                costFactor: 1.2
            },
            {
                id: 'rgb_lighting',
                name: 'RGB Lighting',
                baseCost: 500,
                multiplier: 1.1,
                bonus: 0,
                desc: 'x1.1 Global Multiplier',
                type: 'global_mult',
                costFactor: 2.0
            },
            {
                id: 'streamer_setup',
                name: 'Streamer Setup',
                baseCost: 1200,
                multiplier: 0,
                bonus: 5,
                desc: '+5 Presses per second',
                type: 'auto',
                costFactor: 1.3
            },
            {
                id: 'golden_caps',
                name: 'Golden Keycaps',
                baseCost: 5000,
                multiplier: 0,
                bonus: 10,
                desc: '+10 Press per key',
                type: 'click',
                costFactor: 1.4
            },
            {
                id: 'server_bot',
                name: 'Server Bot Farm',
                baseCost: 25000,
                multiplier: 0,
                bonus: 50,
                desc: '+50 Presses per second',
                type: 'auto',
                costFactor: 1.5
            },
            {
                id: 'quantum_keyboard',
                name: 'Quantum Keyboard',
                baseCost: 100000,
                multiplier: 2.0,
                bonus: 0,
                desc: 'Doubles all production',
                type: 'global_mult',
                costFactor: 5.0
            }
        ];

        const ACHIEVEMENTS = [
            {
                id: 'start',
                name: 'First Click',
                desc: 'Press a key for the first time.',
                condition: (game) => game.stats.totalPresses >= 1,
                icon: 'ðŸ‘†'
            },
            {
                id: 'hundred',
                name: 'Century Club',
                desc: 'Reach 100 total presses.',
                condition: (game) => game.stats.totalPresses >= 100,
                icon: 'ðŸ’¯'
            },
            {
                id: 'speed_demon',
                name: 'Speed Demon',
                desc: 'Reach 10 Presses Per Second.',
                condition: (game) => game.stats.currentPPS >= 10,
                icon: 'âš¡'
            },
            {
                id: 'keyboard_warrior',
                name: 'Keyboard Warrior',
                desc: 'Reach 1,000 total presses.',
                condition: (game) => game.stats.totalPresses >= 1000,
                icon: 'âš”ï¸'
            },
            {
                id: 'upgrade_master',
                name: 'Upgraded',
                desc: 'Purchase 5 upgrades.',
                condition: (game) => game.state.upgradesOwned.reduce((a, b) => a + b.count, 0) >= 5,
                icon: 'ðŸ› ï¸'
            },
            {
                id: 'millionaire',
                name: 'Millionaire',
                desc: 'Reach 1,000,000 total presses.',
                condition: (game) => game.stats.totalPresses >= 1000000,
                icon: 'ðŸ’Ž'
            }
        ];

        const MOCK_LEADERBOARD = [
            { name: 'KeyboardKing', score: 5000000 },
            { name: 'ClickMaster99', score: 2500000 },
            { name: 'WASD_Warrior', score: 1000000 },
            { name: 'SpaceBar_Smasher', score: 750000 },
            { name: 'NoLife', score: 500000 }
        ];

        const UNLOCK_ORDER = ['q', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm'];

        class Game {
            constructor() {
                this.state = {
                    presses: 0,
                    lifetimePresses: 0,
                    manualPresses: 0,
                    pps: 0,
                    clickValue: 1,
                    multiplier: 1.0,
                    startTime: Date.now(),
                    upgradesOwned: UPGRADES.map(u => ({ id: u.id, count: 0 })),
                    achievementsUnlocked: [],
                    unlockedKeys: [' ', 'w', 'a', 's', 'd']
                };

                this.stats = {
                    totalPresses: 0,
                    currentPPS: 0,
                    maxPPS: 0
                };

                this.load();
            }

            pressKey(amount) {
                if (amount === undefined) amount = this.calculateClickValue();

                this.state.presses += amount;
                this.state.lifetimePresses += amount;
                this.stats.totalPresses = this.state.lifetimePresses;
                return amount;
            }

            handleManualPress() {
                this.state.manualPresses++;

                const nextUnlockIndex = this.state.unlockedKeys.length - 5;
                const nextMilestone = (nextUnlockIndex + 1) * 1000;

                if (this.state.manualPresses >= nextMilestone && nextUnlockIndex < UNLOCK_ORDER.length) {
                    const newKey = UNLOCK_ORDER[nextUnlockIndex];
                    this.state.unlockedKeys.push(newKey);

                    alert(`UNLOCKED NEW KEY: ${newKey.toUpperCase()}! Base Click Value Increased +1`);

                    this.recalcStats();
                }

                const value = this.calculateClickValue();
                this.pressKey(value);
                return value;
            }

            isKeyUnlocked(key) {
                return this.state.unlockedKeys.includes(key.toLowerCase());
            }

            calculateClickValue() {
                let base = 1 + (this.state.unlockedKeys.length - 5);
                this.state.upgradesOwned.forEach(owned => {
                    const upgrade = UPGRADES.find(u => u.id === owned.id);
                    if (upgrade.type === 'click') {
                        base += upgrade.bonus * owned.count;
                    }
                });
                return base * this.calculateMultiplier();
            }

            calculatePPS() {
                let pps = 0;
                this.state.upgradesOwned.forEach(owned => {
                    const upgrade = UPGRADES.find(u => u.id === owned.id);
                    if (upgrade.type === 'auto') {
                        pps += upgrade.bonus * owned.count;
                    }
                });
                return pps * this.calculateMultiplier();
            }

            calculateMultiplier() {
                let mult = 1.0;
                this.state.upgradesOwned.forEach(owned => {
                    const upgrade = UPGRADES.find(u => u.id === owned.id);
                    if (upgrade.type === 'global_mult' && owned.count > 0) {
                        mult *= Math.pow(upgrade.multiplier, owned.count);
                    }
                });
                return mult;
            }

            buyUpgrade(upgradeId) {
                const upgrade = UPGRADES.find(u => u.id === upgradeId);
                const owned = this.state.upgradesOwned.find(u => u.id === upgradeId);

                const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costFactor, owned.count));

                if (this.state.presses >= cost) {
                    this.state.presses -= cost;
                    owned.count++;
                    this.recalcStats();
                    return true;
                }
                return false;
            }

            getUpgradeCost(upgradeId) {
                const upgrade = UPGRADES.find(u => u.id === upgradeId);
                const owned = this.state.upgradesOwned.find(u => u.id === upgradeId);
                return Math.floor(upgrade.baseCost * Math.pow(upgrade.costFactor, owned.count));
            }

            recalcStats() {
                this.state.clickValue = this.calculateClickValue();
                this.state.pps = this.calculatePPS();
            }

            tick(dt) {
                const pps = this.state.pps;
                if (pps > 0) {
                    const amount = pps * (dt / 1000);
                    this.state.presses += amount;
                    this.state.lifetimePresses += amount;
                    this.stats.totalPresses = Math.floor(this.state.lifetimePresses);
                }
                this.stats.currentPPS = pps;
            }

            save() {
                localStorage.setItem('kb_master_save', JSON.stringify({
                    state: this.state,
                    stats: this.stats
                }));
            }

            load() {
                const saved = localStorage.getItem('kb_master_save');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        this.state = {
                            ...this.state,
                            ...parsed.state,
                            manualPresses: parsed.state.manualPresses || 0,
                            unlockedKeys: parsed.state.unlockedKeys || [' ', 'w', 'a', 's', 'd']
                        };
                        this.stats = { ...this.stats, ...parsed.stats };
                        this.recalcStats();
                    } catch (e) {
                        console.error('Save file corrupted', e);
                    }
                }
            }

            reset() {
                localStorage.removeItem('kb_master_save');
                location.reload();
            }
        }

        class MinigameSystem {
            constructor(gameInstance, uiCallback) {
                this.game = gameInstance;
                this.uiCallback = uiCallback;
                this.active = false;
                this.currentMinigame = null;
                this.timer = null;
                this.score = 0;
                this.lastPlayed = 0;
                this.cooldown = 15000;
            }

            startMinigame(type) {
                const now = Date.now();
                if (this.active || now - this.lastPlayed < this.cooldown) {
                    return false;
                }

                if (type === 'speed') {
                    this.currentMinigame = {
                        name: 'Speed Challenge',
                        desc: 'Press SPACE as fast as you can!',
                        duration: 10,
                        timeLeft: 10,
                        targetKey: ' ',
                        score: 0,
                        onPress: () => {
                            this.score++;
                            this.game.pressKey(this.game.calculateClickValue());
                        },
                        onEnd: () => {
                            const reward = this.score * 10;
                            this.game.pressKey(reward);
                            alert(`Speed Challenge Complete!\nScore: ${this.score}\nReward: +${reward} presses`);
                        }
                    };
                } else if (type === 'reaction') {
                    this.currentMinigame = {
                        name: 'Reaction Test',
                        desc: 'Press the highlighted key efficiently!',
                        duration: 15,
                        timeLeft: 15,
                        targetKey: null,
                        score: 0,
                        onStart: () => {
                            this.nextReactionKey();
                        },
                        onPress: (key) => {
                            if (key.toLowerCase() === this.currentMinigame.targetKey) {
                                this.score++;
                                this.game.pressKey(this.game.calculateClickValue() * 2);
                                this.nextReactionKey();
                                return true;
                            }
                            return false;
                        },
                        onEnd: () => {
                            const reward = this.score * 25;
                            this.game.pressKey(reward);
                            alert(`Reaction Test Complete!\nScore: ${this.score}\nReward: +${reward} presses`);
                        }
                    };
                }

                this.uiCallback('ready', this.currentMinigame);
            }

            nextReactionKey() {
                if (!this.currentMinigame) return;
                const keys = this.game.state.unlockedKeys;
                const randomKey = keys[Math.floor(Math.random() * keys.length)];
                this.currentMinigame.targetKey = randomKey;
                this.uiCallback('update_instruction', `Press: ${randomKey === ' ' ? 'SPACE' : randomKey.toUpperCase()}`);
            }

            confirmStart() {
                if (!this.currentMinigame) return;
                this.active = true;
                this.score = 0;

                if (this.currentMinigame.onStart) this.currentMinigame.onStart();

                this.uiCallback('start', this.currentMinigame);
                this.timer = setInterval(() => this.tick(), 100);
            }

            tick() {
                if (!this.active || !this.currentMinigame) return;

                this.currentMinigame.timeLeft -= 0.1;
                this.uiCallback('update', {
                    time: this.currentMinigame.timeLeft,
                    score: this.score
                });

                if (this.currentMinigame.timeLeft <= 0) {
                    this.endMinigame();
                }
            }

            handleInput(key) {
                if (!this.active) return false;

                if (this.currentMinigame.name === 'Speed Challenge' && key === ' ') {
                    this.currentMinigame.onPress();
                    this.uiCallback('update', {
                        time: this.currentMinigame.timeLeft,
                        score: this.score
                    });
                    return true;
                } else if (this.currentMinigame.name === 'Reaction Test') {
                    if (this.currentMinigame.onPress(key)) {
                        this.uiCallback('update', {
                            time: this.currentMinigame.timeLeft,
                            score: this.score
                        });
                        return true;
                    }
                }
                return false;
            }

            endMinigame() {
                clearInterval(this.timer);
                if (this.currentMinigame && this.currentMinigame.onEnd) {
                    this.currentMinigame.onEnd();
                }
                this.active = false;
                this.currentMinigame = null;
                this.lastPlayed = Date.now();
                this.uiCallback('end');
            }
        }

        const game = new Game();
        const minigameSystem = new MinigameSystem(game, updateMinigameUI);

        const ui = {
            totalPresses: document.getElementById('total-presses'),
            pps: document.getElementById('pps'),
            keysUnlocked: document.getElementById('keys-unlocked'),
            upgradesList: document.getElementById('upgrades-list'),
            achievementsList: document.getElementById('achievements-list'),
            leaderboardList: document.getElementById('leaderboard-list'),
            mainKey: document.getElementById('main-key'),
            floatingTextContainer: document.getElementById('floating-text-container'),
            minigameOverlay: document.getElementById('minigame-overlay'),
            minigameTitle: document.getElementById('minigame-title'),
            minigameDesc: document.getElementById('minigame-desc'),
            minigameTimer: document.getElementById('minigame-timer'),
            minigameScore: document.getElementById('minigame-score'),
            startMinigameBtn: document.getElementById('start-minigame-btn'),
            btnSpeed: document.getElementById('btn-speed'),
            btnReaction: document.getElementById('btn-reaction'),
            statusText: document.getElementById('minigame-status'),
            activeKeysList: document.getElementById('active-keys-list'),
            cornerProgress: document.getElementById('corner-progress'),
            cornerRemaining: document.getElementById('corner-remaining'),
            modal: null
        };

        let lastTime = 0;

        function init() {
            console.log('Initializing Keyboard Master...');
            renderUpgrades();
            renderAchievements();
            renderLeaderboard();
            updateUI();

            ui.btnSpeed.addEventListener('click', () => {
                try { minigameSystem.startMinigame('speed'); } catch (e) { console.error(e); }
            });

            ui.btnReaction.addEventListener('click', () => {
                try { minigameSystem.startMinigame('reaction'); } catch (e) { console.error(e); }
            });

            requestAnimationFrame(gameLoop);
            setInterval(() => game.save(), 30000);
        }

        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            game.tick(dt);
            minigameSystem.tick(dt);

            updateUI();
            checkAchievements();

            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            if (!ui.totalPresses) return;
            ui.totalPresses.innerText = Math.floor(game.state.presses).toLocaleString();
            ui.pps.innerText = game.stats.currentPPS.toFixed(1);

            const nextUnlockIndex = game.state.unlockedKeys.length - 5;
            const nextMilestone = (nextUnlockIndex + 1) * 1000;

            if (nextUnlockIndex < UNLOCK_ORDER.length) {
                ui.keysUnlocked.innerHTML = `${game.state.unlockedKeys.length} <span style="font-size:0.6em; color:var(--text-muted)">(${game.state.manualPresses}/${nextMilestone})</span>`;
            } else {
                ui.keysUnlocked.innerHTML = `${game.state.unlockedKeys.length} <span style="font-size:0.6em; color:var(--accent-color)">(MAX)</span>`;
            }

            if (ui.activeKeysList) {
                ui.activeKeysList.innerText = "Active Keys: " + game.state.unlockedKeys.map(k => k === ' ' ? 'Space' : k.toUpperCase()).join(', ');
            }

            updateUpgradeAvailability();
            updateChallengeButton();
            updateCornerCounter();
        }

        function updateCornerCounter() {
            if (!ui.cornerProgress) return;

            const nextUnlockIndex = game.state.unlockedKeys.length - 5;
            const nextMilestone = (nextUnlockIndex + 1) * 1000;

            if (nextUnlockIndex < UNLOCK_ORDER.length) {
                ui.cornerProgress.innerHTML = `<span style="color:white">${game.state.manualPresses}</span> / ${nextMilestone}`;
                ui.cornerRemaining.innerText = `${nextMilestone - game.state.manualPresses} clicks to go!`;
            } else {
                ui.cornerProgress.innerText = "ALL UNLOCKED";
                ui.cornerRemaining.innerText = "You are a Keyboard Master!";
            }
        }

        function updateChallengeButton() {
            const now = Date.now();
            const timeLeft = Math.max(0, (minigameSystem.lastPlayed + minigameSystem.cooldown) - now);

            if (minigameSystem.active) {
                ui.statusText.innerText = "Challenge In Progress...";
                ui.btnSpeed.disabled = true;
                ui.btnReaction.disabled = true;
            } else if (timeLeft > 0) {
                ui.statusText.innerText = `Cooldown: ${(timeLeft / 1000).toFixed(1)}s`;
                ui.btnSpeed.disabled = true;
                ui.btnReaction.disabled = true;
            } else {
                ui.statusText.innerText = "Ready to start!";
                ui.btnSpeed.disabled = false;
                ui.btnReaction.disabled = false;
            }
        }

        function updateUpgradeAvailability() {
            if (!ui.upgradesList) return;
            const items = document.querySelectorAll('.upgrade-item');
            items.forEach(item => {
                const cost = parseInt(item.dataset.cost);
                if (game.state.presses >= cost) {
                    item.classList.remove('disabled');
                } else {
                    item.classList.add('disabled');
                }
            });
        }

        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;

            const key = e.key;

            if (minigameSystem.active) {
                if (minigameSystem.handleInput(key)) {
                    spawnFloatingText(key, '+1', true);
                    animateKey(key);
                }
                return;
            }

            if (game.isKeyUnlocked(key)) {
                const value = game.handleManualPress();
                spawnFloatingText(key, `+${value.toFixed(1)}`);
                animateKey(key);
                playClickSound();
                updateUI();
            }
        });

        function spawnFloatingText(key, text, isMinigame = false) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.innerText = text;

            const rect = ui.mainKey.getBoundingClientRect();
            const x = Math.random() * 100 - 50;
            const y = Math.random() * 20 - 10;

            el.style.left = `calc(50% + ${x}px)`;
            el.style.top = `calc(50% + ${y}px)`;

            if (isMinigame) el.style.color = '#ec4899';

            ui.floatingTextContainer.appendChild(el);

            setTimeout(() => el.remove(), 1000);
        }

        function animateKey(key) {
            ui.mainKey.classList.add('pressed');
            setTimeout(() => ui.mainKey.classList.remove('pressed'), 50);
        }

        function playClickSound() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                const ctx = new AudioContext();

                if (ctx.state === 'suspended') {
                    ctx.resume().catch(e => console.error(e));
                }

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800 + Math.random() * 200, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);

                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }

        function renderUpgrades() {
            ui.upgradesList.innerHTML = UPGRADES.map(u => {
                const cost = u.baseCost;
                return `
      <div class="upgrade-item disabled" data-id="${u.id}" data-cost="${cost}">
        <div style="display:flex; justify-content:space-between;">
          <h3>${u.name}</h3>
          <span class="upgrade-cost" id="cost-${u.id}">${cost}</span>
        </div>
        <p class="upgrade-desc">${u.desc}</p>
        <div style="font-size:0.7em; margin-top:5px; color:#64748b">Owned: <span id="count-${u.id}">0</span></div>
      </div>
    `;
            }).join('');

            document.querySelectorAll('.upgrade-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = item.dataset.id;
                    if (game.buyUpgrade(id)) {
                        const nextCost = game.getUpgradeCost(id);
                        const ownedCount = game.state.upgradesOwned.find(u => u.id === id).count;
                        document.getElementById(`cost-${id}`).innerText = nextCost;
                        document.getElementById(`count-${id}`).innerText = ownedCount;
                        item.dataset.cost = nextCost;
                        updateUI();
                    }
                });
            });
        }

        function renderAchievements() {
            ui.achievementsList.innerHTML = ACHIEVEMENTS.map(a => `
     <div class="achievement-item" id="achieve-${a.id}">
       <div class="achieve-icon">${a.icon}</div>
       <div class="achieve-info">
         <h4>${a.name}</h4>
         <p class="achieve-desc">${a.desc}</p>
       </div>
     </div>
  `).join('');
        }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(a => {
                if (!game.state.achievementsUnlocked.includes(a.id)) {
                    if (a.condition(game)) {
                        game.state.achievementsUnlocked.push(a.id);
                        unlockAchievementUI(a.id);
                    }
                } else {
                    const el = document.getElementById(`achieve-${a.id}`);
                    if (el && !el.classList.contains('unlocked')) el.classList.add('unlocked');
                }
            });
        }

        function unlockAchievementUI(id) {
            const el = document.getElementById(`achieve-${id}`);
            if (el) {
                el.classList.add('unlocked');
            }
        }

        function renderLeaderboard() {
            const sorted = MOCK_LEADERBOARD.sort((a, b) => b.score - a.score);
            ui.leaderboardList.innerHTML = sorted.map((entry, index) => `
    <div style="padding: 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; justify-content: space-between;">
      <span>#${index + 1} ${entry.name}</span>
      <span style="color:var(--accent-color)">${entry.score.toLocaleString()}</span>
    </div>
  `).join('');
        }

        function updateMinigameUI(action, data) {
            if (action === 'ready') {
                ui.minigameOverlay.classList.remove('hidden');
                ui.minigameTitle.innerText = data.name;
                ui.minigameDesc.innerText = data.desc;
                ui.minigameTimer.innerText = `Time: ${data.duration}s`;
                ui.minigameScore.innerText = `Score: 0`;
                ui.startMinigameBtn.classList.remove('hidden');
                ui.startMinigameBtn.onclick = () => {
                    minigameSystem.confirmStart();
                    ui.startMinigameBtn.classList.add('hidden');
                };
            } else if (action === 'start') {
                // Game active
            } else if (action === 'update') {
                ui.minigameTimer.innerText = `Time: ${Math.max(0, data.time).toFixed(1)}s`;
                ui.minigameScore.innerText = `Score: ${data.score}`;
            } else if (action === 'update_instruction') {
                ui.minigameDesc.innerText = data;
                ui.minigameDesc.style.color = '#ec4899';
                ui.minigameDesc.style.fontWeight = 'bold';
                ui.minigameDesc.style.fontSize = '1.5em';
            } else if (action === 'end') {
                setTimeout(() => {
                    ui.minigameOverlay.classList.add('hidden');
                }, 1000);
            }
        }

        window.addEventListener('load', init);
    </script>
</body>

</html>